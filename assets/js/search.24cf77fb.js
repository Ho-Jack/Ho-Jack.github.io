(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{294:function(e,t,s){"use strict";s.r(t),t.default=[{title:"table里enum如何渲染色彩",path:"/posts/table%E9%87%8Cenum%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E8%89%B2%E5%BD%A9.html",strippedContent:" > ### 用过滤器和class绑定实现，先过滤不同字段的颜色然后再绑定class    - ### HTML    ```html  <span :class=\"scope.row[key].key | statusFilter\"         v-if=\"key == 'status' || key == 'stockInStatus' || key == 'returnStatus' \">      {{ $format(scope.row[key], column.type, column.format) }}  </span>  ```    - ### 过滤器      ```js    filters: {            // 颜色转换            statusFilter(status) {                const statusMap = {                    'rejected': 'red',                    'nopass': 'red',                    'pass': 'green',                    'finish': 'coral',                    '0-wait':'blue',    //未入库                    '0-no':'blue',    //无退货                    '1-part':'coral',   //部分退货                    '2-finish':'green', //..全部入库                }                return statusMap[status]     //返回对象的value            },    },    ```      - ### CSS        ```css      .red{          color:brown      }      ```  "},{title:"promise实现函数顺序执行",path:"/posts/promise%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C.html",strippedContent:" ### 函数顺序执行    ```js  function2(){      // 你的逻辑代码       return Promise.resolve(/* 这里是需要返回的数据*/)  }    function3(){      // 你的逻辑代码       return Promise.resolve(/* 这里是需要返回的数据*/)  }    // 调用  function1(){      this.function2().then(val => {           this.function3();      });  }  ```    "},{title:"全局过滤器",path:"/posts/%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8.html",strippedContent:" ### 过滤器的基本语法    1. 全局过滤器       ```js     //注册全局过滤器     Vue.filter('myFilter', function (value) {       return  '全局注册器';     })     //使用      {{'调用全局过滤器' | myFilter}}     ```    2. 本地过滤器       ```js     filters: {          filterName(value, flag){       }         //使用      {{'调用全局过滤器' | filterName}}     ```      >  ###  **Object.keys()** 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 [for...in](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in) 循环遍历该对象时返回的顺序一致 。    ```js  var arr = ['a', 'b', 'c'];  console.log(Object.keys(arr)); // console: ['0', '1', '2']    var anObj = { 100: 'a', 2: 'b', 7: 'c' };  console.log(Object.keys(anObj)); // console: ['2', '7', '100']  ```        ![过滤器目录](https://raw.githubusercontent.com/Ho-Jack/daily-note/master/img/过滤器目录.png)    1.   ### 在filter文件夹下创建相关过滤器JS       例如： **dateFilter.js**    ```js  export default {      //日期格式化      format(value){          if(!value){              return \"\"          }          let format = \"yyyy-MM-dd\";          if(value instanceof Date){              return value.format(format);          }else if(typeof value == \"number\"){              return (new Date(value)).format(format);          }else{              return value;          }      }  }  ```    2. ###  **Index.js** 定义全局过滤器（将定义的过滤器集中向外导出）    ```js  import dateFilter from './dateFilter'//日期过滤器  export default {      \"!df\": dateFilter.format,   //日期格式化yyyy-MM-dd                  }  ```    3. ### **main.js**入口文件    ```js  import filters from './filters/' //加载过滤器  (结尾还有/是加载filters目录下的index.js)  //创建全局过滤器  Object.keys(filters).forEach((key) => {      Vue.filter(key, filters[key])//注册过滤器  })  ```    "},{title:"如何注册全局组件",path:"/posts/%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6.html",strippedContent:" ### 注册组件的基本语法：    - 全局注册(这种方式注册组件必须在vue实例化之前声明)      ```js    Vue.component('tag-name',{})    ```    ---    ![全局组件目录](https://raw.githubusercontent.com/Ho-Jack/daily-note/master/img/全局组件目录.png)    ###  在src/compoents/   index.js文件下    1. 引入被注册组件的路径       ```js     import customTable from './custom-el-components/custom-el-table'   //table组件     ```    2. 向外导出       ```js     export default {         customTable,     }     ```    ###  在main.js入口文件下    ```js  import components from './components/' //加载公共组件  // 创建全局组件，组件名的手写字母变大写，加上字母v，用于在模板中和原生的html标签区分出来  // 如组件的名称是project，那创建的组件名称会变成vProject，在模板中就可以直接使用标签<v-project>引用组件  // 函数返回对象的属性名；  Object.keys(components).forEach((key) => {      var name = key.replace(/(\\w)/, (v) => v.toUpperCase()) //首字母大写      Vue.component(`v${name}`, components[key])//注册组件  })  ```          "},{title:"Element-UI中分页组件在项目中如何用",path:"/posts/%E5%88%86%E9%A1%B5%E7%BB%84%E4%BB%B62.0%E7%AE%80%E5%8C%96%E7%89%88.html",strippedContent:' ##  Element-UI 中分页组件在项目中的用法    1. 在html中    ``` html   <el-pagination                @size-change="handleSizeChange"   //改变每页条数时触发的函数                @current-change="handleCurrentChange"   //改变页码时触发的函数                :current-page="pageInfo.pageId"       //当前页码                :page-size="pageInfo.size"            //每页条数                    :page-sizes="[10, 20, 30, 40]"        //每页显示个数选择器的选项设置                layout="total, sizes, prev, pager, next, jumper"    //组件布局，子组件名用逗号分隔                :total="pageInfo.total"              //显示总 条数              ></el-pagination>  ```    2. 在script中       ```js     export default {         data() {           return {          pageInfo: {               size: 10,               pageId: 1,               total: 0             },           },               methods:{                   getList(){                     let params = {               pageStart: this.pageInfo.pageId,    //传当前页码               pageSize: this.pageInfo.size,      //传每页显示条数             }                   //   后面代码省略（用axios请求接口，向接口传入分页信息star和size 返回分页信息）                    //   获取到值得返回一个total值 表示共几条信息                   }               }         }     ```  '},{title:"Element-UI中table组件的简单封装",path:"/posts/table2.0.html",strippedContent:" ## Element-UI中 table组件在项目中简单封装    > 暂时还没有添加 双击列表跳转进入编辑页的事件    1. 在html里       ``` html        <el-table               id=\"dataContainer\"               ref=\"dataContainer\"               :data=\"tableData\"               border               stripe               tooltip-effect=\"dark\"               style=\"width:100%;\"             >               <el-table-column type=\"index\" width=\"55\" align=\"center\">               </el-table-column>               <el-table-column v-for=\"(column, key) in columns\"                                :key=\"key\"                                :prop=\"column.prop\"                                :label=\"column.label\"                                :width=\"column.width\"                                :align=\"column.align || 'center'\"                                :sortable=\"column.sortable\"                                :show-overflow-tooltip=\"true\">                 <template slot-scope=\"scope\">                   \x3c!--普通列--\x3e                   <span v-if=\"column.type =='common'\">   {{ scope.row[column.prop] }}  </span>                   \x3c!--图片--\x3e                   <div v-else-if=\"column.type=='img'\" style=\"text-align:center\">                     <img :src='scope.row[column.prop]' style=\"width:200px; height:100px;\">                   </div>                   \x3c!--类型为枚举enumTag，显示为tag--\x3e           <div class=\"tag-list-wrap\" v-else-if=\"column.type=='enumTag' && scope.row[column.prop]\">                     <template v-for=\"item of column.enumList\">                       <el-tag v-if=\"scope.row[column.prop].desc === item.desc\"                               @click.stop=\"$emit('tagClick', item.key)\"                               :style=\"item.clickable ? 'cursor: pointer;' : ''\" :type=\"item.type\">                         {{ item.desc }}                       </el-tag>                     </template>                   </div>                   \x3c!--类型为format--\x3e                   <div v-else-if=\"column.type ==='format'\">                     {{ column.format(scope.row[column.prop])}}                   </div>                   \x3c!--有操作栏--\x3e                   <div v-else-if=\"column.type=='operations'\">               <el-button   v-for=\"item of column.actions\" size=\"small\"                                @click.stop=\"handleOperationsClick(item.action,scope.row)\" type=\"text\"                   :disabled=\"handleDisable(item.action, scope.row)\" >                       {{ item.label }}                     </el-button>                   </div>                 </template>               </el-table-column>             </el-table>     ```       2. script          ```js         import columns from './config/columns'   //将表格栏的信息封装进columns好管理        export default{            data(){                return{               tableData: [],  // table数据 axios请求到的数据仍进来就可以渲染列表数据                columns: columns.new(),  //拿到table的栏信息                }            },            methods:{                 //操作栏，传入一个type是按钮的类型  一个row是当前行的所有信息        handleOperationsClick(type, row) {                switch (type) {            case 'enable':                    this.toEdit(row);                    break;                  case 'disable':                    this.doDisable(row);                    break;                  case 'delete':                    this.doDelete(row);                    break;                  default:                    break;                },                                  },            }        }        ```          3. 在config文件夹下的columns.js             >   向外导出一个 数组对象             ```js           //列表的数据模型           import moment  from 'moment';  //引入moment.js插件需要npm 下载 主要对时间格式化           export default {                      //返回数据模型实例             new: function () {               return [                 {                   type:'common',                   prop: 'name',                   label: '昵称',//列名称                   visible: true,//是否显示                   sortable: false,//是否可排序                 },                            {                   type:'img',                   prop: 'picPath',                   label: '图片',//列名称                   width:'400px',                   visible: true,//是否显示                   sortable: false,//是否可排序                 },                 {                   type: 'format',                   prop: 'time',                   label: '创建时间',//列名称                   visible: true,//是否显示                   sortable: false,//是否可排序                   format: function(time){                     return new moment(time).format('YYYY-MM-DD ');                   },                 },                            {                   type:'enumTag',                   prop: 'status',                   label: '状态',//列名称                   visible: true,//是否显示                   sortable: false,//是否可排序                   enumList: [                     {                       key: 'enable',                       desc: '启用',                       type: 'success'                     },                     {                       key: 'disable',                       desc: '禁用',                       type: 'danger'                     },                   ],                 },                 {                   label: '操作',                   width: '180',                   type:'operations',                   visible: true,                   fixed: 'right',                   align: 'center',                   actions: [               {                       action:'enable',                       label:'启用'                     },                     {                       action: 'disable',                       label: '禁用'                     },                     {                       action: 'delete',                       label: '删除'                     },                   ],                 }               ]             }           }                                            ```  "},{title:"Vue中混入mixin的使用",path:"/posts/mixin.html",strippedContent:" ###  关于VUE的混入使用    -     ###  普通使用：    1. 定义一个mixin.js文件       ![混入](https://raw.githubusercontent.com/Ho-Jack/daily-note/master/img/mixin1.png)    2. 随便写一些数据       ```js     const mixin ={         data(){             return{                 message:'hello',                 foo:'abc'             };         }     };     export default mixin;   //记得导出     ```    3. 使用       ```js     <script>         import mixin form '../common/mixin';     export default {         mixins: [mixin],         data(){             return{                 items:[1,2,3,4,5,6],                 nextNum:10             }         },         created(){             console.log(this.message); //直接使用了mixin里面的message         }     }                       <\/script>     ```      - ### 全局混合：      1. 在mixin.js 文件中，引入vue 并且注册全局混合         ![全局混合](https://raw.githubusercontent.com/Ho-Jack/daily-note/master/img/mixin2.png)         ```js       import Vue form 'vue';       Vue.mixin({           data(){               return{                   haha:'你好啊'               };           },           methods:{               conText(){                   console.log(this.haha)               }           }       })       ```      2. 在其他页面直接使用       ```js     <script>         export default{     data(){         return{                      }     },         created(){             this.conTest()  //这是全局mixin里的一个方法         }     }     <\/script>     ```  "},{title:"Vuex知识要点",path:"/posts/VUEX.html",strippedContent:" # Vuex 知识    *  ### 基础知识总结      > store( state、mutations、actions、getters)    * state 用来数据共享数据存储                                   $store.state.xxx    * mutation 用来注册改变数据状态（同步）               $store.commit( mutation名称 )    * action 解决异步改变共享数据( 异步 )                      $store.dispatch( action名称，data)    * getters 用来对共享数据进行过滤操作（计算属性）$store.getters.xx          >在组件中分发 state、mutations 、actions 、getters  >* **...mapActions([   '你要获取的actions名字'   ])**，你传入什么，就会返回一个包含对应的actions的对象，通过...对象扩展运算符，将返回值解析就成为methods的属性，和平常的方法一样调用即可  >  >  **mapActions**、**mapMutations**、   **①**必须先引用   **②**且要放在 **methods**中。  >  >  **mapState、mapGetters **              **①**必须先引用 **②**并且放在**computed**中  ```js  import { mapActions } from 'vuex'   //引用  export default {   // ...      methods: {          ...mapActions([  'increment', // 将 `this.increment()` 映射为`this.$store.dispatch('increment')`               // `mapActions` 也支持载荷：    'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`          ]),          ...mapActions({              add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')`          })      }}  ```  1.   ```js  const state ={      AA: ' '  }  const  mutations={      BB(state,{对象1}){           //更新state的操作      }  }  const actions ={      CC({commit,state},对象1){          commit(BB,{对象1})    //触发mutations里的BB函数      }  }  const getters ={      DD(state){          return  state.AA  }  ```    2.   ```js  const moduleA = {      state: {...},      mutations: {...},      actions: {...},      getters: {...}  }  const moduleB = {      state: {...},      mutations: {...},      actions: {...},  }  const store =new Vuex.Store({                  modules:{                  a:moduleA,                  b:moduleB                  }              })      store.state.a      //  获取moduleA      store.state.b      //  获取moduleB      ```        * ### 项目中的使用实例      1. 在store文件夹下创建 index.js   (这是配置vuex的入口)         ```js       import Vue from 'vue'       import Vuex from 'vuex'       import user from './user'  //包含state、mutations、actions、getter的modules       Vue.use(Vuex)              export default new Vuex.Store({             modules: {               user,   //store.state.user  获取user的状态           }       })       ```         2. 在store文件夹下创建 user.js         ```js       import Vue from 'vue'       export const USER_SIGNIN = 'USER_SIGNIN' //登录成功     向外导出这个方法       export const USER_SIGNOUT = 'USER_SIGNOUT' //退出登录   向外导出这个方法       export default {           state: JSON.parse(sessionStorage.getItem('userInfo')) || {},           mutations: {               [USER_SIGNIN](state, userInfo) {                   sessionStorage.setItem('userInfo', JSON.stringify(userInfo));                   sessionStorage.setItem('token', userInfo.token);                   Object.assign(state, userInfo)               },               [USER_SIGNOUT](state) {                   sessionStorage.clear();                   console.log('state ', Object.keys(state));                   Object.keys(state).forEach(k => Vue.delete(state, k))               }           },           actions: {               [USER_SIGNIN]({ commit }, userInfo) {                   commit(USER_SIGNIN, userInfo)               },               [USER_SIGNOUT]({ commit }) {                   commit(USER_SIGNOUT)               }           }       ```         3.  main.js入口文件            ```js          import store from './store/'   //结尾还有一个 / 这是寻找到store文件夹下的index.js入口文件          new Vue({              store,}          ```            4.使用            ```js          import {  mapActions} from 'vuex'          import { USER_SIGNIN} from 'store/user'          methods: {              ...mapActions([USER_SIGNIN]),              login() {                  this.$refs.loginModel.validate((valid) => {                      if (valid) {                          let params = {                              username: this.loginModel.username,                              password: this.loginModel.password,                              mark :true                              //captcha: this.loginModel.captcha                          };                          this.$api.post('/login', params, (data, isOK, message) => {                              if (!isOK) {                                  this.$api.error(message)                                  return false                              }          //记录记住用户名和密码                 localStorage.setItem('autologin',this.loginModel.autologin)                 localStorage.setItem('username', this.loginModel.username)                 localStorage.setItem('password', this.loginModel.password)                              let userInfo = data;                              //保存用户登录信息，共享到state                              this.USER_SIGNIN(userInfo)                              this.$router.push(\"/bmManagement/page\")                          })                      } else {                          console.log('error submit!!')                          return false;                      }                  });              },          ```        ```js  computed: mapState({      user: state => state.user,//从全局存储里取出当前登录用户信息      menuTabList: state => state.menuTab.menuTabList,//从全局存储里取出当前打开的菜单tab     }),    ```    "},{title:"Element-UI,table表格里单选按钮妙用",path:"/posts/table%E8%A1%A8%E6%A0%BC%E4%B8%AD%E5%8D%95%E9%80%89%E6%8C%89%E9%92%AE%E5%A6%99%E7%94%A8.html",strippedContent:' - table表格组件中单选按钮    ```html  <el-table-column width="40" align="center" header-align="center">     <template scope="scope">        <el-radio class="radio" v-model="AA" :label="scope.row"></el-radio>     </template>  </el-table-column>  ```    1. 每一行选中的值（scope.row）这个对象都存进了 v-model绑定的对象AA中    2. 在watch这个钩子函数中监控AA       ```js       watch:{          \'AA\' (value ){                  //执行函数,如保存当前选中行的值，或者根据当前行的值做一些操作                     }                       }     ```  '},{title:"import",path:"/posts/import.html",strippedContent:" ##  import * as  xx  from   'xx'    > 导出的内容组合成一个对象返回；    在xx.js下  ```js  export const  x1={   }  export const  x2={   }  ```    ## import   xx    from '   xx'    > 导出这个默认 **xx** 的对象作为一个对象    在xx.js下  ```js  const xx ={}  export default xx  ```    "},{title:"QS插件",path:"/posts/qs%E6%8F%92%E4%BB%B6.html",strippedContent:" ##    qc是一个增加了一些安全性的查询字符串解析和序列化字符串的库      1. 下载   在项目中使用命令行工具输入：npm install qs  2. 安装完成后在需要用到的组件中：      import qs from  'qs’  > ###   主要的**2**个方法   **qs.parse() **   **qs.stringify()**    ```js  qs.parse()         //是将URL解析成对象的形式       >对象  qs.stringify() //是将对象 序列化成URL的形式，以&进行拼接    >url  ```    "},{title:"Vue实例里this的使用",path:"/posts/Vue%E5%AE%9E%E4%BE%8B%E9%87%8Cthis%E7%9A%84%E4%BD%BF%E7%94%A8.html",strippedContent:' # Vue实例里this的使用    > ### 在Vue所有的生命周期钩子方法（如created，mounted， updated以及destroyed）里使用this，  >  > ### this指向调用它的Vue实例。     ```js  <!DOCTYPE html>  <html>  <head>      <meta charset="UTF-8">      <title></title>      <script src="http://libs.baidu.com/jquery/2.0.0/jquery.js"><\/script>      <script src="https://unpkg.com/vue@2.5.9/dist/vue.js"><\/script>  </head>  <div id="app" style="width: 100%;height: auto;font-size:20px;">      <p id="id1"></p>      <p id="id2"></p>  </div>  <script type="text/javascript">      var message = "Hello!";      var app = new Vue({          el:"#app",          data:{              message: "你好！"          },          created: function() {            this.showMessage1();    //this 1   指向vue实例            this.showMessage2();   //this 2     指向vue实例            //  created函数为vue实例的钩子方法，它里面使用的this指的是vue实例。          },          methods:{              showMessage1:function(){                  setTimeout( function() {                     document.getElementById("id1").innerText = this.message;  //this 3                       //普通函数，这里的this是window  所以输出 Hello！          //   对于普通函数（包括匿名函数），this指的是直接的调用者，在非严格模式下，如果没有直接调用者，this指的是window。showMessage1()里setTimeout使用了匿名函数，this指向window。                  }, 10)              },              showMessage2:function() {                  setTimeout(() => {                     document.getElementById("id2").innerText = this.message;  //this 4      //箭头函数，箭头函数是没有自己的this，在它内部使用的this是由它定义的宿主对象决定。      //showMessage2()里定义的箭头函数宿主对象为vue实例，所以它里面使用的this指向vue实例。                      //输出 你好！                  }, 10)              }          }      });  <\/script>  </html>  ```        ### 绑定vue实例到this的方法    为了避免this指向出现歧义，有两种方法绑定this。      **1.使用bind**    showMessage1()可以改为：    ```js  howMessage1:function(){      setTimeout(function() {         document.getElementById("id1").innerText = this.message;  //this 3      }.bind(this), 10)  }  ```    对setTimeout()里的匿名函数使用bind()绑定到vue实例的this。这样在匿名函数内的this也为vue实例。      **2.把vue实例的this赋值给另一个变量再使用**  that=this     showMessage1()也可以改为    ```js  showMessage1:function(){      var that = this;      setTimeout(function() {         document.getElementById("id1").innerText = that.message;  //改为that      }.bind(this), 10)  }  ```'},{title:"this在Vue中的指向",path:"/posts/this%E5%9C%A8vue%E4%B8%AD%E7%9A%84%E6%8C%87%E5%90%91.html",strippedContent:' ## this在Vue中的指向    我们知道，如果Vue的data中有属性message，那么方法中直接用this.message就可以获取到这个message的值    > ### 在Vue的methdos方法，普通函数的this指向的就是Vue的实例，this.message可以获取到data中的值，  >  ### 而箭头函数的this指向了window，不能获取到值  ```js  <!DOCTYPE html>  <html lang="en">  <head>      <meta charset="UTF-8">      <title>Document</title>      <script src="https://unpkg.com/vue@2.5.16/dist/vue.js"><\/script>  </head>  <body>      <div id="app">         <button v-on:click="getMessage">获取message的值</button>       </div>      <script>          new Vue({              el : \'#app\',              data : {                  message : "hello vue!"              },              methods : {                                  // 普通函数this的指向是其调用者                  getMessage : function(){                      // alert(this.message);                      console.log(this);  // 指向Vue的实例                  },                    // 箭头函数的this指向了window，其实应该指向vue的实例                  // 箭头函数的指向是其定义的外部函数（有宿主对象决定）                  getMessage : ()=>{                      console.log(this);  // window                  }              }          })      <\/script>  </body>  </html>  ```     > ##   methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 ` this` 自动绑定为 Vue 实例。     注意，**不应该使用箭头函数来定义 method 函数** (例如 `plus: () => this.a++`)。理由是箭头函数绑定了父级作用域的上下文，所以 `this` 将不会按照期望指向 Vue 实例，`this.a` 将是 undefined。    '},{title:"Element-UI中分页组件在项目中如何用",path:"/posts/this%E5%9C%A8axios%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98.html",strippedContent:"## this在axios的指向问题    - ### 在Vue中this始终指向Vue，但axios中this为undefined，例如    ```js  methods:{      loadData:function(){          axios.get('static/mock.json')              .then( function (response){              //this为undefined              response=response.data              this.title=response.title          })              .catch( function(error){              console.log(error)          })      }  }  ```    - ### 若需要赋值给变量用以渲染数据，可以通过=>函数，这时this为Vue    ```javascript  methods:{      loadData:function(){          axios.get('static/mock.json')              .then(  (response)=>{              //this为undefined              response=response.data              this.title=response.title          })              .catch( function(error){              console.log(error)          })      }  }  ```    - ### 或者可以直接通过：       ###  let that = this     ### 将this保存在that中，再在函数中使用that均可     "},{title:"运算符",path:"/posts/%E8%BF%90%E7%AE%97%E7%AC%A6.html",strippedContent:' **&&** 第一个运算数是false，就不再考虑第二个运算数，直接返回false。    **||**  第一个运算数是true，也不再考虑第二个运算数，直接返回true。    **&** 和  **|** 运算符却不是这样的，它们总是要比较两个运算数才得出结果，因而性能上&&和||会比&和|好。         #### 功能用法    &&和||只能进行逻辑运算，而&和|除了可以进行"逻辑运算"外，还可以进行位运算    ![运算符](https://raw.githubusercontent.com/Ho-Jack/daily-note/master/img/运算符.png)'},{title:"sessionStroage应用要点",path:"/posts/sessionStroage.%E5%BA%94%E7%94%A8%E8%A6%81%E7%82%B9.html",strippedContent:" * #### 基本使用      ```js    sessionStorage.setItem( key, value);    ```      * #### sessionStorage 的使用注意事项:      > sessionStorage 不能将对象、数组等格式的数据作为 value 进行存储    1. 如果存储对象、数组等格式的数据，需要将数据格式转为字符串格式，然后进行存储       ```js     sessionStorage.setItem( key, JSON.stringify(myData));     ```    2. · 使用时直接从 sessionStorage 中获取：       ```js     const myData = JSON.parse(sessionStorage.getItem(key) || null);     ```      "},{title:"Element-UI表单校验",path:"/posts/%E6%A0%A1%E9%AA%8C%E8%A7%84%E5%88%99.html",strippedContent:' ### elment-ui表单校验    ```html  <el-form  label-width="130px" :model="form" :rules="rules" ref="form">  <el-form-item label="作者" prop="author">      <el-input v-model="form.author"></el-input>  </el-form-item>  </el-form>  ```    - #### 注意要点    ```js  1、：rules=rules    // rules定义在data里  2、prop = xx        // xx是form对象里面的xx  也是rules里的校验对象         form : { xx : ’  ’  }   、   rules:{ xx:[  ]}  3、this.$refs[form].validate( ( valid ) =>{  If ( valid ){  //校验成功，执行的函数  }else{ return false}  })  4、 清除输入      this.$refs[formName].resetFields();  ```        - 在外部JS里    ```js  import rules from \'@/config/rules\'  //这里是定义好的规则  export default {      mainRules: {          "vueThis":null,  //用来设置vue实例          "main.name": [rules.required(),rules.limit(0,250)],          "main.remark": [rules.limit(0,250)],          "main.orgType.key": [rules.required()],          "main.programa": [rules.required()],      }  }  ```    - 在script里      ```js    import rules from \'./config/rules\';  //引入外部JS    ```    - 在data里      ```js    rules: rules.mainRules,\t    form: {    main: model.mainModel(),    },        ```    - 在当前js里      ```js    mounted() {    //给规则的vueThisv赋值    this.rules.vueThis = this;    }，    //校验方法    this.$refs["form"].validate((valid) => {    if (valid) {    }else{        return false    }    });    ```  '},{title:"前端常用状态码",path:"/posts/%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E7%8A%B6%E6%80%81%E7%A0%81.html",strippedContent:" 1XX：指示信息——表示请求已经接收，继续处理。    2XX：成功——表示请求已被成功接收、理解、接受。     3XX：重定向——要完成请求必须进行更进一步的操作。    4XX：客服端错误——请求有语法错误或者请求无法实现。    5XX：服务器错误——服务器未能实现合法的请求。        ###  **常见的HTTP状态码：**    **200——OK，请求成功**    301——Moved Permanently，资源（网页等）被永久转移到其他URL    302——Found，307——Temporary Redirect，临时重定向，请求的文档被临时移动到别处    304——Not Modified，未修改，表示客户端缓存的版本是最近的    401——Unauthorized，请求要求用户的身份认证    403——Forbidden，禁止，服务器理解客户端请求，但是拒绝处理此请求，通常是权限设置所致    **404——Not Found，请求的资源（网页等）不存在     *（接口不存在）**    **500——Internal Server Error——内部服务器错误**    502——Bad Gateway，充当网关或代理的服务器从远端服务器接收到了一个无效的请求    504——Gateway Time-out，充当网关或代理的服务器，未及时从远端服务器获取请求"},{title:"开发杂记",path:"/posts/%E5%BC%80%E5%8F%91%E6%9D%82%E8%AE%B0.html",strippedContent:' ##### a标签下载问题    ```h5  <a  href="写的是相对路径"          download = “ 不写默认文件名，作用是防止浏览器对jpg等格式文件直接打开而不是下载” />  ```    ##### 导出功能    ```js  window.open(url)   //url是接口，后台提供的导出接口  ```    '},{title:"按钮悬停样式",path:"/posts/%E6%8C%89%E9%92%AE%E5%81%9C%E7%95%99%E6%A0%B7%E5%BC%8F.html",strippedContent:" ```css      /deep/ .btn-next:focus, .btn-next:hover {          background: #1e8e9e;          border-color: #1e8e9e;        }  ```    "},{title:"记一次开发趣事",path:"/posts/%E6%8E%A5%E5%8F%A3%E5%AF%B9%E8%B1%A1%E4%BC%A0%E5%8F%82%EF%BC%88%E5%BC%80%E5%8F%91%E8%B6%A3%E4%BA%8B%EF%BC%89.html",strippedContent:" - 我写的      ```js    let params = {}    let start = this.pageInfo.pageId;//页码    let size = this.pageInfo.size;//每页行数    params.pageStart = start;    params.pageSize = size;    params.tenantId = 1;    ```    - 大佬写的      ```js    let params={      pageStart:this.pageInfo.pageId,      pageSize:this.pageInfo.size      tenantId :1    }    ```      > 总结： 我就是个弟弟。  刚出来工作那会，写页面分页的时候我写的代码，一顿操作，哗啦啦写下来，虽然实现了功能，但是写了很多臃肿的代码，大佬看到后，一番操作，让我体会到我写的代码还是很多问题，但是我相信在我不断的学习和实践下，我一定会有突破和进步。"}]}}]);